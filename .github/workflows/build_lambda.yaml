name: Build and Push Lambda Docker Images Optimized

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  ECR_REPO: "${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/etl-expenses"
  TF_VAR_OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
  TF_VAR_TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin ${ECR_REPO}

      - name: Build and Push Lambda images
        run: |
          set -x
          # Lista de directorios con Lambdas (ajustada a tu estructura)
          LAMBDA_DIRS=(
            "ai_agent"
            "compensation_flow" 
            "extract_data_bank_pay"
            "extract_data_mp"
            "extract_data_pdf"
            "load_data"
            "redshift_to_bq"
            "transform_data_bank_pay"
            "transform_data_mp"
            "transform_data_pdf"
            "webhook_mp_report"
          )
      
          for LAMBDA_DIR in "${LAMBDA_DIRS[@]}"; do
            echo "üìÅ Processing: $LAMBDA_DIR"
            
            # 1. Buscar Dockerfile con naming pattern [nombre_dir].dockerfile
            DOCKERFILE="${LAMBDA_DIR}/${LAMBDA_DIR}.dockerfile"
            
            if [[ ! -f "$DOCKERFILE" ]]; then
              echo "‚ö†Ô∏è No ${LAMBDA_DIR}.dockerfile found in $LAMBDA_DIR, skipping"
              continue
            fi

            # 2. Calcular hash m√°s preciso (incluye todos los archivos relevantes)
            CONTENT_HASH=$(find $LAMBDA_DIR -type f \( -name '*.py' -o -name 'requirements.txt' -o -name 'Dockerfile' \) \
                        -exec sha256sum {} \; | sort | sha256sum | cut -d' ' -f1)
            SHORT_HASH=${CONTENT_HASH:0:12}
            IMAGE_TAG="${LAMBDA_DIR}-${SHORT_HASH}"
            
            # 3. Verificar si la imagen ya existe
            if aws ecr describe-images --repository-name etl-expenses \
              --image-ids imageTag="$IMAGE_TAG" &>/dev/null; then
              echo "üîÑ No changes detected, updating latest tag only"
              
              # Actualizar tag latest usando el manifest existente
              aws ecr batch-get-image --repository-name etl-expenses \
                --image-ids imageTag="$IMAGE_TAG" \
                --query 'images[].imageManifest' --output text | \
                xargs -I {} aws ecr put-image \
                  --repository-name etl-expenses \
                  --image-tag "${LAMBDA_DIR}-latest" \
                  --image-manifest "{}"
            else
              echo "üöÄ Changes detected, building new image..."
              
              # 4. Construir con manejo de errores
              if ! docker build -t "${ECR_REPO}:${IMAGE_TAG}" \
                  -f "$LAMBDA_DIR/Dockerfile" "$LAMBDA_DIR"; then
                echo "‚ùå Build failed for $LAMBDA_DIR"
                exit 1
              fi
              
              # 5. Push con reintentos
              for i in {1..3}; do
                docker push "${ECR_REPO}:${IMAGE_TAG}" && break || 
                (echo "‚ö†Ô∏è Push attempt $i failed" && sleep 5)
              done

              # 6. Actualizar Lambda function si existe
              if aws lambda get-function --function-name ${LAMBDA_DIR//_/-} &>/dev/null; then
                echo "üîÑ Updating Lambda function..."
                aws lambda update-function-code \
                  --function-name ${LAMBDA_DIR//_/-} \
                  --image-uri "${ECR_REPO}:${IMAGE_TAG}" \
                  --region ${{ env.AWS_REGION }}
              fi

              # 7. Limpieza segura (m√°ximo 5 im√°genes antiguas)
              aws ecr describe-images --repository-name etl-expenses \
                --filter "tagStatus=TAGGED" \
                --query "sort_by(imageDetails,& imagePushedAt)[?starts_with(imageTags[0], '${LAMBDA_DIR}-') && imageTags[0]!='${IMAGE_TAG}' && imageTags[0]!='${LAMBDA_DIR}-latest']" \
                --output json | jq -r '.[5:][].imageDigest' | while read digest; do
                  aws ecr batch-delete-image \
                    --repository-name etl-expenses \
                    --image-ids imageDigest=$digest
                done
            fi
          done
                
  terraform-deploy:
    needs: [build-and-push]
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.6

      - name: Terraform Init
        run: |
          set -x
          terraform init
          
          # Import existing ECR repository
          terraform import aws_ecr_repository.lambda_images etl-expenses || true
          
          # Import existing API Gateway and resources
          terraform import aws_api_gateway_rest_api.telegram_webhook $(aws apigateway get-rest-apis --query "items[?name=='telegram-redshift-bot'].id" --output text) || true
          
          API_ID=$(aws apigateway get-rest-apis --query "items[?name=='telegram-redshift-bot'].id" --output text)
          if [ ! -z "$API_ID" ]; then
            ROOT_ID=$(aws apigateway get-resources --rest-api-id $API_ID --query "items[?path=='/'].id" --output text)
            WEBHOOK_ID=$(aws apigateway get-resources --rest-api-id $API_ID --query "items[?path=='/webhook'].id" --output text)
            
            if [ ! -z "$WEBHOOK_ID" ]; then
              echo "üîÑ Importing existing API Gateway resources..."
              terraform import aws_api_gateway_resource.webhook $API_ID/$WEBHOOK_ID || true
              terraform import aws_api_gateway_method.post $API_ID/$WEBHOOK_ID/POST || true
              terraform import aws_api_gateway_integration.lambda $API_ID/$WEBHOOK_ID/POST || true
              
              # Import Lambda permission with correct format
              echo "üîê Importing Lambda permission for API Gateway..."
              terraform import aws_lambda_permission.allow_api_gateway "ai-agent/AllowAPIGatewayInvoke" || true
              
              # Verify the import
              if [ $? -ne 0 ]; then
                echo "‚ö†Ô∏è Failed to import Lambda permission, trying alternative format..."
                terraform import aws_lambda_permission.allow_api_gateway "arn:aws:lambda:${{ env.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:function:ai-agent/AllowAPIGatewayInvoke" || true
              fi
            else
              echo "‚ö†Ô∏è Webhook resource not found in API Gateway"
            fi
          else
            echo "‚ö†Ô∏è API Gateway 'telegram-redshift-bot' not found"
          fi
          
          # Import other existing resources
          terraform import aws_s3_bucket.market_tickets market-tickets || true
          terraform import aws_s3_bucket.mp_reports mercadopago-reports || true
          terraform import aws_s3_bucket.bank_payments bank-payments || true
          
          terraform import aws_iam_policy.step_function_lambda_policy arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:policy/step_function_lambda_policy || true
          terraform import aws_iam_policy.step_function_start_policy arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:policy/step_function_start_policy || true
          terraform import aws_iam_policy.step_function_glue_policy arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:policy/step_function_glue_policy || true
          terraform import aws_iam_policy.lambda_redshift_access arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:policy/lambda_redshift_access || true
          terraform import aws_iam_policy.lambda_ecr_access arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:policy/lambda_ecr_access || true
          terraform import aws_iam_policy.lambda_bedrock_access arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:policy/lambda_bedrock_access || true
          terraform import aws_iam_policy.lambda_s3_access arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:policy/lambda_s3_access || true

          terraform import aws_redshiftserverless_namespace.etl_namespace pdf-etl-namespace || true
          terraform import aws_lambda_permission.allow_api_gateway ai-agent/AllowAPIGatewayInvoke || true

          terraform import aws_lambda_function.dispatcher dispatcher || true
          terraform import aws_lambda_function.compensation_flow compensation-flow || true
          terraform import aws_lambda_function.pdf_extractor pdf_extractor || true
          terraform import aws_lambda_function.pdf_processor pdf_processor || true
          terraform import aws_lambda_function.mp_report_extractor mp_report_extractor || true
          terraform import aws_lambda_function.mp_report_processor mp_report_processor || true
          terraform import aws_lambda_function.bank_payments_extractor bank_payments_extractor || true
          terraform import aws_lambda_function.bank_payments_processor bank_payments_processor || true
          terraform import aws_lambda_function.redshift-to-bq redshift-to-bq || true
          terraform import aws_lambda_function.ai_agent ai-agent || true
          terraform import aws_lambda_function.load_report_and_pdf load_report_and_pdf || true
          
          terraform import aws_iam_role.lambda_exec lambda_exec_role || true
          terraform import aws_iam_role.step_function_role step_function_role || true
          terraform import aws_iam_role.glue_service_role glue_service_role || true

          terraform import aws_sfn_state_machine.pdf_etl_flow arn:aws:states:${{ secrets.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:stateMachine:pdf-etl-flow || true
          terraform import aws_sfn_state_machine.mp_report_etl_flow arn:aws:states:${{ secrets.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:stateMachine:mp-report-etl-flow || true
          terraform import aws_sfn_state_machine.bank_payments_etl_flow arn:aws:states:${{ secrets.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:stateMachine:bank-payments-etl-flow || true

          terraform import aws_glue_catalog_database.etl_database "${{ secrets.AWS_ACCOUNT_ID }}:etl_database" || true
          terraform import aws_glue_crawler.market_tickets_crawler market-tickets-crawler || true
          terraform import aws_glue_crawler.mp_reports_crawler mp-reports-crawler || true
          terraform import aws_glue_crawler.bank_payments_crawler bank-payments-crawler || true

          terraform import aws_redshiftserverless_workgroup.etl_workgroup pdf-etl-workgroup || true

          terraform import aws_cloudwatch_log_group.etl_logs /aws/vendedlogs/states/etl-logs || true  
        
        env:
          TF_VAR_aws_account_id: ${{ env.AWS_ACCOUNT_ID }}
          TF_VAR_aws_region: ${{ env.AWS_REGION }}
          TF_VAR_email: ${{ secrets.EMAIL }}
          TF_VAR_TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TF_VAR_OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

      - name: Terraform Apply
        run: |
          set -x
          terraform apply -auto-approve
        env:
          TF_VAR_aws_account_id: ${{ env.AWS_ACCOUNT_ID }}
          TF_VAR_aws_region: ${{ env.AWS_REGION }}
          TF_VAR_email: ${{ secrets.EMAIL }}
          TF_VAR_TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TF_VAR_OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

      - name: Get Webhook URL (Robust)
        id: webhook
        run: |
          set -x
          # Extraer SOLO la URL usando grep y sed
          RAW_OUTPUT=$(terraform output webhook_url)
          WEBHOOK_URL=$(echo "$RAW_OUTPUT" | grep -o 'https://[^[:space:]]*' | head -n1 | sed 's/"//g')
          
          # Validar formato
          if [[ ! "$WEBHOOK_URL" =~ ^https://.* ]]; then
            echo "‚ùå Error: URL malformada - '$WEBHOOK_URL'"
            exit 1
          fi
          
          echo "webhook_url=$WEBHOOK_URL" >> $GITHUB_OUTPUT
          echo "‚úÖ Webhook URL limpia: $WEBHOOK_URL"
          
      - name: Configure Telegram Webhook
        run: |
          set -x
          # Usar directamente la variable del paso anterior
          WEBHOOK_URL="${{ steps.webhook.outputs.webhook_url }}"
          
          echo "Configurando webhook con URL: $WEBHOOK_URL"
          
          curl -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/setWebhook" \
              -H "Content-Type: application/json" \
              -d "{\"url\": \"$WEBHOOK_URL\"}"
          
          echo "Webhook configurado exitosamente"
                
      - name: Verify Webhook
        run: |
          set -x
          curl -X GET "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/getWebhookInfo" | jq .
