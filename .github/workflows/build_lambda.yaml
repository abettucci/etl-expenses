name: Build and Push Lambda Docker Images Optimized

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  ECR_REPO: "${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/etl-expenses"
  TF_VAR_OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
  TF_VAR_TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin ${ECR_REPO}

      - name: Get list of Lambda directories
        id: list_dirs
        run: |
          dirs=$(find . -type f -name 'lambda_function.py' -exec dirname {} \;)
          echo "lambda_dirs<<EOF" >> $GITHUB_OUTPUT
          echo "$dirs" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Process Lambda directories
        run: |
          set -x
          echo "${{ steps.list_dirs.outputs.lambda_dirs }}" | while read dir; do
            LAMBDA_NAME=$(basename $dir)
            echo "ðŸ“ Processing directory: $dir"

            # Calcular hash de los archivos relevantes
            HASH=$(find $dir -type f \( -name '*.py' -o -name 'requirements.txt' -o -name '*.dockerfile' \) -exec sha256sum {} \; | \
                   sort | sha256sum | cut -d ' ' -f1)
            SHORT_HASH=$(echo $HASH | cut -c1-12)
            IMAGE_TAG="${LAMBDA_NAME}-${SHORT_HASH}"
            IMAGE_URI="${ECR_REPO}:${IMAGE_TAG}"
            LATEST_TAG="${ECR_REPO}:${LAMBDA_NAME}-latest"

            # Verificar si la imagen ya existe
            if aws ecr describe-images --repository-name etl-expenses \
               --image-ids imageTag=$IMAGE_TAG &>/dev/null; then
              echo "ðŸ”„ Image ${IMAGE_URI} already exists, skipping build"
              
              # Actualizar tag latest
              MANIFEST=$(aws ecr batch-get-image --repository-name etl-expenses \
                --image-ids imageTag=$IMAGE_TAG --query 'images[].imageManifest' --output text)
              aws ecr put-image --repository-name etl-expenses \
                --image-tag $LAMBDA_NAME-latest --image-manifest "$MANIFEST"
            else
              # Construir y pushear nueva imagen
              echo "ðŸš€ Building new image: ${IMAGE_URI}"
              DOCKERFILE=$(ls $dir/*.dockerfile | head -n1)
              
              docker build -t $IMAGE_URI -f $DOCKERFILE $dir
              docker push $IMAGE_URI
              
              # Actualizar tag latest
              docker tag $IMAGE_URI $LATEST_TAG
              docker push $LATEST_TAG

              # Limpiar imÃ¡genes antiguas (mantener solo las 2 mÃ¡s recientes)
              aws ecr list-images --repository-name etl-expenses \
                --filter "tagStatus=TAGGED" --query "imageIds[?starts_with(imageTag, '${LAMBDA_NAME}-')]" \
                --output json | jq -r 'sort_by(.imageTag)[0:-2][] | .imageDigest' | \
                while read digest; do
                  aws ecr batch-delete-image --repository-name etl-expenses \
                    --image-ids imageDigest=$digest
                done
            fi

            # Actualizar funciÃ³n Lambda si existe
            if aws lambda get-function --function-name $LAMBDA_NAME &>/dev/null; then
              echo "ðŸ”„ Updating Lambda function: $LAMBDA_NAME"
              aws lambda update-function-code \
                --function-name $LAMBDA_NAME \
                --image-uri $IMAGE_URI \
                --region ${{ env.AWS_REGION }}
            fi
          done

  terraform-deploy:
    needs: [build-and-push]
    runs-on: ubuntu-latest
    
    steps:
      # ... (mantener tus pasos existentes de terraform-deploy)